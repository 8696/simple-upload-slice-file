(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("SimpleUploadSliceFile", [], factory);
	else if(typeof exports === 'object')
		exports["SimpleUploadSliceFile"] = factory();
	else
		root["SimpleUploadSliceFile"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/getMd5.js":
/*!***********************!*\
  !*** ./src/getMd5.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
/*
 * Fastest md5 implementation around (JKM md5).
 * Credits: Joseph Myers
 *
 * @see http://www.myersdaily.org/joseph/javascript/md5-text.html
 * @see http://jsperf.com/md5-shootout/7
 */

/* this function is much faster,
  so if possible we use it. Some IEs
  are the only ones I know of that
  need the idiotic second function,
  generated by an if clause.  */
var add32 = function add32(a, b) {
    return a + b & 0xFFFFFFFF;
},
    hex_chr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];

function cmn(q, a, b, x, s, t) {
    a = add32(add32(a, q), add32(x, t));
    return add32(a << s | a >>> 32 - s, b);
}

function md5cycle(x, k) {
    var a = x[0],
        b = x[1],
        c = x[2],
        d = x[3];

    a += (b & c | ~b & d) + k[0] - 680876936 | 0;
    a = (a << 7 | a >>> 25) + b | 0;
    d += (a & b | ~a & c) + k[1] - 389564586 | 0;
    d = (d << 12 | d >>> 20) + a | 0;
    c += (d & a | ~d & b) + k[2] + 606105819 | 0;
    c = (c << 17 | c >>> 15) + d | 0;
    b += (c & d | ~c & a) + k[3] - 1044525330 | 0;
    b = (b << 22 | b >>> 10) + c | 0;
    a += (b & c | ~b & d) + k[4] - 176418897 | 0;
    a = (a << 7 | a >>> 25) + b | 0;
    d += (a & b | ~a & c) + k[5] + 1200080426 | 0;
    d = (d << 12 | d >>> 20) + a | 0;
    c += (d & a | ~d & b) + k[6] - 1473231341 | 0;
    c = (c << 17 | c >>> 15) + d | 0;
    b += (c & d | ~c & a) + k[7] - 45705983 | 0;
    b = (b << 22 | b >>> 10) + c | 0;
    a += (b & c | ~b & d) + k[8] + 1770035416 | 0;
    a = (a << 7 | a >>> 25) + b | 0;
    d += (a & b | ~a & c) + k[9] - 1958414417 | 0;
    d = (d << 12 | d >>> 20) + a | 0;
    c += (d & a | ~d & b) + k[10] - 42063 | 0;
    c = (c << 17 | c >>> 15) + d | 0;
    b += (c & d | ~c & a) + k[11] - 1990404162 | 0;
    b = (b << 22 | b >>> 10) + c | 0;
    a += (b & c | ~b & d) + k[12] + 1804603682 | 0;
    a = (a << 7 | a >>> 25) + b | 0;
    d += (a & b | ~a & c) + k[13] - 40341101 | 0;
    d = (d << 12 | d >>> 20) + a | 0;
    c += (d & a | ~d & b) + k[14] - 1502002290 | 0;
    c = (c << 17 | c >>> 15) + d | 0;
    b += (c & d | ~c & a) + k[15] + 1236535329 | 0;
    b = (b << 22 | b >>> 10) + c | 0;

    a += (b & d | c & ~d) + k[1] - 165796510 | 0;
    a = (a << 5 | a >>> 27) + b | 0;
    d += (a & c | b & ~c) + k[6] - 1069501632 | 0;
    d = (d << 9 | d >>> 23) + a | 0;
    c += (d & b | a & ~b) + k[11] + 643717713 | 0;
    c = (c << 14 | c >>> 18) + d | 0;
    b += (c & a | d & ~a) + k[0] - 373897302 | 0;
    b = (b << 20 | b >>> 12) + c | 0;
    a += (b & d | c & ~d) + k[5] - 701558691 | 0;
    a = (a << 5 | a >>> 27) + b | 0;
    d += (a & c | b & ~c) + k[10] + 38016083 | 0;
    d = (d << 9 | d >>> 23) + a | 0;
    c += (d & b | a & ~b) + k[15] - 660478335 | 0;
    c = (c << 14 | c >>> 18) + d | 0;
    b += (c & a | d & ~a) + k[4] - 405537848 | 0;
    b = (b << 20 | b >>> 12) + c | 0;
    a += (b & d | c & ~d) + k[9] + 568446438 | 0;
    a = (a << 5 | a >>> 27) + b | 0;
    d += (a & c | b & ~c) + k[14] - 1019803690 | 0;
    d = (d << 9 | d >>> 23) + a | 0;
    c += (d & b | a & ~b) + k[3] - 187363961 | 0;
    c = (c << 14 | c >>> 18) + d | 0;
    b += (c & a | d & ~a) + k[8] + 1163531501 | 0;
    b = (b << 20 | b >>> 12) + c | 0;
    a += (b & d | c & ~d) + k[13] - 1444681467 | 0;
    a = (a << 5 | a >>> 27) + b | 0;
    d += (a & c | b & ~c) + k[2] - 51403784 | 0;
    d = (d << 9 | d >>> 23) + a | 0;
    c += (d & b | a & ~b) + k[7] + 1735328473 | 0;
    c = (c << 14 | c >>> 18) + d | 0;
    b += (c & a | d & ~a) + k[12] - 1926607734 | 0;
    b = (b << 20 | b >>> 12) + c | 0;

    a += (b ^ c ^ d) + k[5] - 378558 | 0;
    a = (a << 4 | a >>> 28) + b | 0;
    d += (a ^ b ^ c) + k[8] - 2022574463 | 0;
    d = (d << 11 | d >>> 21) + a | 0;
    c += (d ^ a ^ b) + k[11] + 1839030562 | 0;
    c = (c << 16 | c >>> 16) + d | 0;
    b += (c ^ d ^ a) + k[14] - 35309556 | 0;
    b = (b << 23 | b >>> 9) + c | 0;
    a += (b ^ c ^ d) + k[1] - 1530992060 | 0;
    a = (a << 4 | a >>> 28) + b | 0;
    d += (a ^ b ^ c) + k[4] + 1272893353 | 0;
    d = (d << 11 | d >>> 21) + a | 0;
    c += (d ^ a ^ b) + k[7] - 155497632 | 0;
    c = (c << 16 | c >>> 16) + d | 0;
    b += (c ^ d ^ a) + k[10] - 1094730640 | 0;
    b = (b << 23 | b >>> 9) + c | 0;
    a += (b ^ c ^ d) + k[13] + 681279174 | 0;
    a = (a << 4 | a >>> 28) + b | 0;
    d += (a ^ b ^ c) + k[0] - 358537222 | 0;
    d = (d << 11 | d >>> 21) + a | 0;
    c += (d ^ a ^ b) + k[3] - 722521979 | 0;
    c = (c << 16 | c >>> 16) + d | 0;
    b += (c ^ d ^ a) + k[6] + 76029189 | 0;
    b = (b << 23 | b >>> 9) + c | 0;
    a += (b ^ c ^ d) + k[9] - 640364487 | 0;
    a = (a << 4 | a >>> 28) + b | 0;
    d += (a ^ b ^ c) + k[12] - 421815835 | 0;
    d = (d << 11 | d >>> 21) + a | 0;
    c += (d ^ a ^ b) + k[15] + 530742520 | 0;
    c = (c << 16 | c >>> 16) + d | 0;
    b += (c ^ d ^ a) + k[2] - 995338651 | 0;
    b = (b << 23 | b >>> 9) + c | 0;

    a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;
    a = (a << 6 | a >>> 26) + b | 0;
    d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;
    d = (d << 10 | d >>> 22) + a | 0;
    c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;
    c = (c << 15 | c >>> 17) + d | 0;
    b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;
    b = (b << 21 | b >>> 11) + c | 0;
    a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;
    a = (a << 6 | a >>> 26) + b | 0;
    d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;
    d = (d << 10 | d >>> 22) + a | 0;
    c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;
    c = (c << 15 | c >>> 17) + d | 0;
    b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;
    b = (b << 21 | b >>> 11) + c | 0;
    a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;
    a = (a << 6 | a >>> 26) + b | 0;
    d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;
    d = (d << 10 | d >>> 22) + a | 0;
    c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;
    c = (c << 15 | c >>> 17) + d | 0;
    b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;
    b = (b << 21 | b >>> 11) + c | 0;
    a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;
    a = (a << 6 | a >>> 26) + b | 0;
    d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;
    d = (d << 10 | d >>> 22) + a | 0;
    c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;
    c = (c << 15 | c >>> 17) + d | 0;
    b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;
    b = (b << 21 | b >>> 11) + c | 0;

    x[0] = a + x[0] | 0;
    x[1] = b + x[1] | 0;
    x[2] = c + x[2] | 0;
    x[3] = d + x[3] | 0;
}

function md5blk(s) {
    var md5blks = [],
        i;
    /* Andy King said do it this way. */

    for (i = 0; i < 64; i += 4) {
        md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
    }
    return md5blks;
}

function md5blk_array(a) {
    var md5blks = [],
        i;
    /* Andy King said do it this way. */

    for (i = 0; i < 64; i += 4) {
        md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);
    }
    return md5blks;
}

function md51(s) {
    var n = s.length,
        state = [1732584193, -271733879, -1732584194, 271733878],
        i,
        length,
        tail,
        tmp,
        lo,
        hi;

    for (i = 64; i <= n; i += 64) {
        md5cycle(state, md5blk(s.substring(i - 64, i)));
    }
    s = s.substring(i - 64);
    length = s.length;
    tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    for (i = 0; i < length; i += 1) {
        tail[i >> 2] |= s.charCodeAt(i) << (i % 4 << 3);
    }
    tail[i >> 2] |= 0x80 << (i % 4 << 3);
    if (i > 55) {
        md5cycle(state, tail);
        for (i = 0; i < 16; i += 1) {
            tail[i] = 0;
        }
    }

    // Beware that the final length might not fit in 32 bits so we take care of that
    tmp = n * 8;
    tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
    lo = parseInt(tmp[2], 16);
    hi = parseInt(tmp[1], 16) || 0;

    tail[14] = lo;
    tail[15] = hi;

    md5cycle(state, tail);
    return state;
}

function md51_array(a) {
    var n = a.length,
        state = [1732584193, -271733879, -1732584194, 271733878],
        i,
        length,
        tail,
        tmp,
        lo,
        hi;

    for (i = 64; i <= n; i += 64) {
        md5cycle(state, md5blk_array(a.subarray(i - 64, i)));
    }

    // Not sure if it is a bug, however IE10 will always produce a sub array of length 1
    // containing the last element of the parent array if the sub array specified starts
    // beyond the length of the parent array - weird.
    // https://connect.microsoft.com/IE/feedback/details/771452/typed-array-subarray-issue
    a = i - 64 < n ? a.subarray(i - 64) : new Uint8Array(0);

    length = a.length;
    tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    for (i = 0; i < length; i += 1) {
        tail[i >> 2] |= a[i] << (i % 4 << 3);
    }

    tail[i >> 2] |= 0x80 << (i % 4 << 3);
    if (i > 55) {
        md5cycle(state, tail);
        for (i = 0; i < 16; i += 1) {
            tail[i] = 0;
        }
    }

    // Beware that the final length might not fit in 32 bits so we take care of that
    tmp = n * 8;
    tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
    lo = parseInt(tmp[2], 16);
    hi = parseInt(tmp[1], 16) || 0;

    tail[14] = lo;
    tail[15] = hi;

    md5cycle(state, tail);

    return state;
}

function rhex(n) {
    var s = '',
        j;
    for (j = 0; j < 4; j += 1) {
        s += hex_chr[n >> j * 8 + 4 & 0x0F] + hex_chr[n >> j * 8 & 0x0F];
    }
    return s;
}

function hex(x) {
    var i;
    for (i = 0; i < x.length; i += 1) {
        x[i] = rhex(x[i]);
    }
    return x.join('');
}

// In some cases the fast add32 function cannot be used..
if (hex(md51('hello')) !== '5d41402abc4b2a76b9719d911017c592') {
    add32 = function add32(x, y) {
        var lsw = (x & 0xFFFF) + (y & 0xFFFF),
            msw = (x >> 16) + (y >> 16) + (lsw >> 16);
        return msw << 16 | lsw & 0xFFFF;
    };
}

// ---------------------------------------------------

/**
 * ArrayBuffer slice polyfill.
 *
 * @see https://github.com/ttaubert/node-arraybuffer-slice
 */

if (typeof ArrayBuffer !== 'undefined' && !ArrayBuffer.prototype.slice) {
    (function () {
        function clamp(val, length) {
            val = val | 0 || 0;

            if (val < 0) {
                return Math.max(val + length, 0);
            }

            return Math.min(val, length);
        }

        ArrayBuffer.prototype.slice = function (from, to) {
            var length = this.byteLength,
                begin = clamp(from, length),
                end = length,
                num,
                target,
                targetArray,
                sourceArray;

            if (to !== undefined) {
                end = clamp(to, length);
            }

            if (begin > end) {
                return new ArrayBuffer(0);
            }

            num = end - begin;
            target = new ArrayBuffer(num);
            targetArray = new Uint8Array(target);

            sourceArray = new Uint8Array(this, begin, num);
            targetArray.set(sourceArray);

            return target;
        };
    })();
}

// ---------------------------------------------------

/**
 * Helpers.
 */

function toUtf8(str) {
    if (/[\u0080-\uFFFF]/.test(str)) {
        str = unescape(encodeURIComponent(str));
    }

    return str;
}

function utf8Str2ArrayBuffer(str, returnUInt8Array) {
    var length = str.length,
        buff = new ArrayBuffer(length),
        arr = new Uint8Array(buff),
        i;

    for (i = 0; i < length; i += 1) {
        arr[i] = str.charCodeAt(i);
    }

    return returnUInt8Array ? arr : buff;
}

function arrayBuffer2Utf8Str(buff) {
    return String.fromCharCode.apply(null, new Uint8Array(buff));
}

function concatenateArrayBuffers(first, second, returnUInt8Array) {
    var result = new Uint8Array(first.byteLength + second.byteLength);

    result.set(new Uint8Array(first));
    result.set(new Uint8Array(second), first.byteLength);

    return returnUInt8Array ? result : result.buffer;
}

function hexToBinaryString(hex) {
    var bytes = [],
        length = hex.length,
        x;

    for (x = 0; x < length - 1; x += 2) {
        bytes.push(parseInt(hex.substr(x, 2), 16));
    }

    return String.fromCharCode.apply(String, bytes);
}

// ---------------------------------------------------

/**
 * SparkMD5 OOP implementation.
 *
 * Use this class to perform an incremental md5, otherwise use the
 * static methods instead.
 */

function SparkMD5() {
    // call reset to init the instance
    this.reset();
}

/**
 * Appends a string.
 * A conversion will be applied if an utf8 string is detected.
 *
 * @param {String} str The string to be appended
 *
 * @return {SparkMD5} The instance itself
 */
SparkMD5.prototype.append = function (str) {
    // Converts the string to utf8 bytes if necessary
    // Then append as binary
    this.appendBinary(toUtf8(str));

    return this;
};

/**
 * Appends a binary string.
 *
 * @param {String} contents The binary string to be appended
 *
 * @return {SparkMD5} The instance itself
 */
SparkMD5.prototype.appendBinary = function (contents) {
    this._buff += contents;
    this._length += contents.length;

    var length = this._buff.length,
        i;

    for (i = 64; i <= length; i += 64) {
        md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));
    }

    this._buff = this._buff.substring(i - 64);

    return this;
};

/**
 * Finishes the incremental computation, reseting the internal state and
 * returning the result.
 *
 * @param {Boolean} raw True to get the raw string, false to get the hex string
 *
 * @return {String} The result
 */
SparkMD5.prototype.end = function (raw) {
    var buff = this._buff,
        length = buff.length,
        i,
        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        ret;

    for (i = 0; i < length; i += 1) {
        tail[i >> 2] |= buff.charCodeAt(i) << (i % 4 << 3);
    }

    this._finish(tail, length);
    ret = hex(this._hash);

    if (raw) {
        ret = hexToBinaryString(ret);
    }

    this.reset();

    return ret;
};

/**
 * Resets the internal state of the computation.
 *
 * @return {SparkMD5} The instance itself
 */
SparkMD5.prototype.reset = function () {
    this._buff = '';
    this._length = 0;
    this._hash = [1732584193, -271733879, -1732584194, 271733878];

    return this;
};

/**
 * Gets the internal state of the computation.
 *
 * @return {Object} The state
 */
SparkMD5.prototype.getState = function () {
    return {
        buff: this._buff,
        length: this._length,
        hash: this._hash
    };
};

/**
 * Gets the internal state of the computation.
 *
 * @param {Object} state The state
 *
 * @return {SparkMD5} The instance itself
 */
SparkMD5.prototype.setState = function (state) {
    this._buff = state.buff;
    this._length = state.length;
    this._hash = state.hash;

    return this;
};

/**
 * Releases memory used by the incremental buffer and other additional
 * resources. If you plan to use the instance again, use reset instead.
 */
SparkMD5.prototype.destroy = function () {
    delete this._hash;
    delete this._buff;
    delete this._length;
};

/**
 * Finish the final calculation based on the tail.
 *
 * @param {Array}  tail   The tail (will be modified)
 * @param {Number} length The length of the remaining buffer
 */
SparkMD5.prototype._finish = function (tail, length) {
    var i = length,
        tmp,
        lo,
        hi;

    tail[i >> 2] |= 0x80 << (i % 4 << 3);
    if (i > 55) {
        md5cycle(this._hash, tail);
        for (i = 0; i < 16; i += 1) {
            tail[i] = 0;
        }
    }

    // Do the final computation based on the tail and length
    // Beware that the final length may not fit in 32 bits so we take care of that
    tmp = this._length * 8;
    tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
    lo = parseInt(tmp[2], 16);
    hi = parseInt(tmp[1], 16) || 0;

    tail[14] = lo;
    tail[15] = hi;
    md5cycle(this._hash, tail);
};

/**
 * Performs the md5 hash on a string.
 * A conversion will be applied if utf8 string is detected.
 *
 * @param {String}  str The string
 * @param {Boolean} [raw] True to get the raw string, false to get the hex string
 *
 * @return {String} The result
 */
SparkMD5.hash = function (str, raw) {
    // Converts the string to utf8 bytes if necessary
    // Then compute it using the binary function
    return SparkMD5.hashBinary(toUtf8(str), raw);
};

/**
 * Performs the md5 hash on a binary string.
 *
 * @param {String}  content The binary string
 * @param {Boolean} [raw]     True to get the raw string, false to get the hex string
 *
 * @return {String} The result
 */
SparkMD5.hashBinary = function (content, raw) {
    var hash = md51(content),
        ret = hex(hash);

    return raw ? hexToBinaryString(ret) : ret;
};

// ---------------------------------------------------

/**
 * SparkMD5 OOP implementation for array buffers.
 *
 * Use this class to perform an incremental md5 ONLY for array buffers.
 */
SparkMD5.ArrayBuffer = function () {
    // call reset to init the instance
    this.reset();
};

/**
 * Appends an array buffer.
 *
 * @param {ArrayBuffer} arr The array to be appended
 *
 * @return {SparkMD5.ArrayBuffer} The instance itself
 */
SparkMD5.ArrayBuffer.prototype.append = function (arr) {
    var buff = concatenateArrayBuffers(this._buff.buffer, arr, true),
        length = buff.length,
        i;

    this._length += arr.byteLength;

    for (i = 64; i <= length; i += 64) {
        md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));
    }

    this._buff = i - 64 < length ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);

    return this;
};

/**
 * Finishes the incremental computation, reseting the internal state and
 * returning the result.
 *
 * @param {Boolean} raw True to get the raw string, false to get the hex string
 *
 * @return {String} The result
 */
SparkMD5.ArrayBuffer.prototype.end = function (raw) {
    var buff = this._buff,
        length = buff.length,
        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        i,
        ret;

    for (i = 0; i < length; i += 1) {
        tail[i >> 2] |= buff[i] << (i % 4 << 3);
    }

    this._finish(tail, length);
    ret = hex(this._hash);

    if (raw) {
        ret = hexToBinaryString(ret);
    }

    this.reset();

    return ret;
};

/**
 * Resets the internal state of the computation.
 *
 * @return {SparkMD5.ArrayBuffer} The instance itself
 */
SparkMD5.ArrayBuffer.prototype.reset = function () {
    this._buff = new Uint8Array(0);
    this._length = 0;
    this._hash = [1732584193, -271733879, -1732584194, 271733878];

    return this;
};

/**
 * Gets the internal state of the computation.
 *
 * @return {Object} The state
 */
SparkMD5.ArrayBuffer.prototype.getState = function () {
    var state = SparkMD5.prototype.getState.call(this);

    // Convert buffer to a string
    state.buff = arrayBuffer2Utf8Str(state.buff);

    return state;
};

/**
 * Gets the internal state of the computation.
 *
 * @param {Object} state The state
 *
 * @return {SparkMD5.ArrayBuffer} The instance itself
 */
SparkMD5.ArrayBuffer.prototype.setState = function (state) {
    // Convert string to buffer
    state.buff = utf8Str2ArrayBuffer(state.buff, true);

    return SparkMD5.prototype.setState.call(this, state);
};

SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;

SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;

/**
 * Performs the md5 hash on an array buffer.
 *
 * @param {ArrayBuffer} arr The array buffer
 * @param {Boolean}     [raw] True to get the raw string, false to get the hex one
 *
 * @return {String} The result
 */
SparkMD5.ArrayBuffer.hash = function (arr, raw) {
    var hash = md51_array(new Uint8Array(arr)),
        ret = hex(hash);

    return raw ? hexToBinaryString(ret) : ret;
};

/**
 * @description 重新包装该方法
 * */
function getFileMd5(options) {
    var file = options.file;
    var md5Str;
    var blobSlice = File.prototype.slice || File.prototype.mozSlice || File.prototype.webkitSlice,

    // file = this.files[0],
    chunkSize = 8097152,
        // Read in chunks of 2MB
    chunks = Math.ceil(file.size / chunkSize),
        currentChunk = 0,
        spark = new SparkMD5.ArrayBuffer(),
        fileReader = new FileReader();

    fileReader.onload = function (e) {
        // console.log('read chunk nr', currentChunk + 1, 'of', chunks);
        spark.append(e.target.result); // Append array buffer
        currentChunk++;
        var md5_progress = Math.floor(currentChunk / chunks * 100);
        options.progress && options.progress({
            fileName: file.name,
            progress: md5_progress
        });
        if (currentChunk < chunks) {
            loadNext();
        } else {
            md5Str = spark.end();
            options.success && options.success({
                md5: md5Str,
                msg: 'success'
            });
            options.complete && options.complete({
                result: true
            });
            // console.log(md5Str);
        }
    };

    fileReader.onerror = function () {
        options.error && options.error({
            md5: '',
            msg: 'error'
        });
        options.complete && options.complete({
            result: false
        });
    };

    function loadNext() {
        var start = currentChunk * chunkSize,
            end = start + chunkSize >= file.size ? file.size : start + chunkSize;
        fileReader.readAsArrayBuffer(blobSlice.call(file, start, end));
    }

    loadNext();
}

exports.default = getFileMd5;

/***/ }),

/***/ "./src/http.js":
/*!*********************!*\
  !*** ./src/http.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _queue = __webpack_require__(/*! ./queue.send */ "./src/queue.send.js");

var _queue2 = _interopRequireDefault(_queue);

var _tool = __webpack_require__(/*! ./tool */ "./src/tool.js");

var _tool2 = _interopRequireDefault(_tool);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Http = function () {
    function Http(options) {
        _classCallCheck(this, Http);

        this.url = options.url;
        this.formData = _tool2.default.deepClone(options.formData, {});
        this.headers = _tool2.default.deepClone(options.headers || {}, {});
        this.fileData = options.fileData || {};
        this.callBack = options.callBack || {};
        this.sliceTryFreq = options.sliceTryFreq;
        this.isCheckMd5Request = options.isCheckMd5Request || false;
        this.delay = options.delay;
    }

    _createClass(Http, [{
        key: 'send',
        value: function send() {
            var _this = this;

            var nowUploadKey = null;
            if (this.fileData.fieldName) {
                // 当前发送的key
                nowUploadKey = this.fileData.fieldName;
            }

            // 追加到队列
            _queue2.default.queue.push({
                delay: this.delay,
                // 本次请求切片所属字段
                fieldName: this.fileData.fieldName,
                // 本次请求切片在文件的第几块
                order: this.fileData.order || '',
                trySend: 0,
                // 最大限度每个切片允许上传失败次数
                maxTrySend: this.sliceTryFreq,
                isCheckMd5Request: this.isCheckMd5Request,
                cancelSend: function cancelSend(isCheckMd5Request) {
                    if (isCheckMd5Request) {
                        _this.callBack.checkMd5Result && _this.callBack.checkMd5Result({
                            httpStatus: _queue2.default.lastHttpStatus,
                            response: null
                        });
                    } else {
                        // 取消本文件的所以切片上传
                        _queue2.default.removeField(_this.fileData.fieldName);
                        _this.callBack.tryFreqError && _this.callBack.tryFreqError({
                            httpStatus: _queue2.default.lastHttpStatus,
                            fieldName: _this.fileData.fieldName, // 字段名称
                            order: _this.fileData.order // 在第几块一直失败
                        });
                    }
                },

                // 队列执行函数
                fn: function fn() {
                    var formData = new FormData();
                    var xhr = new XMLHttpRequest();
                    //
                    var url = _this.url;
                    if (/\?/.test(url)) {
                        url = url + '&upload-random=' + _tool2.default.makeRandom();
                    } else {
                        url = url + '?upload-random=' + _tool2.default.makeRandom();
                    }
                    xhr.open('post', url, true);
                    // 循环追加数据
                    for (var key in _this.formData) {
                        formData.append(key, _this.formData[key]);
                    }
                    // 循环追加请求头
                    for (var _key in _this.headers) {
                        xhr.setRequestHeader(_key, _this.headers[_key]);
                    }

                    if (nowUploadKey) {
                        // 追加文件
                        formData.append(_this.fileData.fieldName /*file key*/
                        , _this.fileData['file']['blob'] /*blob*/
                        , _this.fileData['fileName'] /*file name*/);
                    }

                    // 监听状态改变
                    xhr.onreadystatechange = function () {

                        if (xhr.readyState === 4 && xhr.status === 200) {
                            // 返回200，表示一个文件请求成功，通知删除该请求队列
                            _queue2.default.sendSuccess();
                            _this.callBack.singleSuccess && _this.callBack.singleSuccess({
                                field: _this.fileData.fieldName,
                                status: xhr.status,
                                response: xhr.responseText
                            });
                            try {
                                // 是否是校验md5请求
                                if (_this.isCheckMd5Request) {
                                    _this.callBack.checkMd5Result && _this.callBack.checkMd5Result({
                                        httpStatus: _queue2.default.lastHttpStatus,
                                        response: typeof xhr.responseText === 'string' ? JSON.parse(xhr.responseText) : xhr.responseText
                                    });
                                }
                            } catch (e) {
                                throw new Error(e.toString());
                            }
                        }

                        if (xhr.readyState === 4 && xhr.status === 206) {
                            // 返回206，表示一块切片请求成功，通知删除该请求队列
                            _queue2.default.sendSuccess();
                            _this.callBack.sliceSuccess && _this.callBack.sliceSuccess({
                                status: xhr.status,
                                response: xhr.responseText
                            });
                        }
                        // 请求完成，继续下一次请求，如果后台报非200 || 206则没有通知上传成功，会继续发送上一次请求
                        if (xhr.readyState === 4) {
                            // 保存最后一次HTTP状态码
                            _queue2.default.lastHttpStatus = xhr.status;
                            _queue2.default.isSendLoading = false;
                            _queue2.default.send();
                        }
                    };
                    // 监听进度
                    xhr.upload.onprogress = function (evt) {
                        if (evt.lengthComputable) {

                            // this.callBack.progress && this.callBack.progress(Math.round(evt.loaded / evt.total * 100));
                            _this.callBack.progress && _this.callBack.progress(_defineProperty({}, nowUploadKey, evt.loaded));
                        }
                    };
                    xhr.send(formData);
                }
            });
            _queue2.default.send();
        }
    }]);

    return Http;
}();

exports.default = Http;

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! ./polyfill */ "./src/polyfill.js");

var _upload = __webpack_require__(/*! ./upload */ "./src/upload.js");

var _upload2 = _interopRequireDefault(_upload);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = _upload2.default;

/***/ }),

/***/ "./src/polyfill.js":
/*!*************************!*\
  !*** ./src/polyfill.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * @description  解决IE不认识 Object.assign 的问题
 * @description2 采用自 https://developer.mozilla.org/zh-CN/
 * */

if (typeof Object.assign != 'function') {
    // Must be writable: true, enumerable: false, configurable: true
    Object.defineProperty(Object, "assign", {
        value: function assign(target, varArgs) {
            // .length of function is 2
            'use strict';

            if (target == null) {
                // TypeError if undefined or null
                throw new TypeError('Cannot convert undefined or null to object');
            }

            var to = Object(target);

            for (var index = 1; index < arguments.length; index++) {
                var nextSource = arguments[index];

                if (nextSource != null) {
                    // Skip over if undefined or null
                    for (var nextKey in nextSource) {
                        // Avoid bugs when hasOwnProperty is shadowed
                        if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                            to[nextKey] = nextSource[nextKey];
                        }
                    }
                }
            }
            return to;
        },
        writable: true,
        configurable: true
    });
}

/***/ }),

/***/ "./src/queue.send.js":
/*!***************************!*\
  !*** ./src/queue.send.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = {
    isSendLoading: false,
    queue: [],
    lastHttpStatus: 0,
    send: function send() {
        var _this = this;

        if (!this.isSendLoading) {
            if (this.queue.length > 0) {
                this.isSendLoading = true;
                setTimeout(function () {
                    _this.queue[0].trySend++;
                    // 判断一块切片是否已经超过指定失败数
                    if (_this.queue[0].trySend <= _this.queue[0].maxTrySend) {
                        _this.queue[0].fn();
                    } else {
                        console.log(_this.queue[0].isCheckMd5Request);
                        _this.queue[0].cancelSend(_this.queue[0].isCheckMd5Request /*取消类型，false文件 || true校验MD5*/);
                    }
                }, this.queue[0].delay);
            }
        }
    },
    // 是否发送成功，成功删除上一次队列的请求，否则继续重发
    sendSuccess: function sendSuccess() {
        this.queue.splice(0, 1);
    },

    // 移除指定字段的所有队列
    removeField: function removeField(fieldName) {
        this.queue = this.queue.filter(function (item) {
            return item.fieldName !== fieldName;
        });
        // 继续发送
        this.isSendLoading = false;
        this.send();
    }
};

/***/ }),

/***/ "./src/slice.js":
/*!**********************!*\
  !*** ./src/slice.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Slice = function () {
    function Slice(options) {
        _classCallCheck(this, Slice);

        // 文件
        this.file = options.file;
        // 文件大小
        this.totalSize = this.file.size;
        // 切片大小
        this.chunkSile = options.chunkSile * 1024 * 1024;
        // 需要传输几次
        this.chunkLength = 0;
        // 切片集合
        this.slices = [];

        // 切片开始位置
        this.start = 0;
        // 切片结束位置
        this.end = 0;

        this._compute();
    }

    /**
     * @description 计算总共需要传输几次
     * @return {Object} this
     * */


    _createClass(Slice, [{
        key: "_compute",
        value: function _compute() {
            // console.log('文件总大小' + this.totalSize);
            if (this.totalSize <= this.chunkSile) {
                this.chunkLength = 1;
            } else {
                this.chunkLength = Math.ceil(this.totalSize / this.chunkSile);
            }
            // console.log(this.chunkLength);
        }

        /**
         * @description 获取该文件对象所以切片
         * @return {Array} 切片集合
         * */

    }, {
        key: "getSlice",
        value: function getSlice() {
            if (this.slices.length !== 0) {
                return this.slices;
            }
            for (var i = 1; i <= this.chunkLength; i++) {
                // 如果是总共传输一次或者最后一次
                if (i === this.chunkLength || this.chunkLength === 1) {
                    this.end = this.totalSize;
                } else {
                    this.end = i * this.chunkSile;
                }
                // 剪切文件
                var blob = this.file.slice(this.start, this.end);

                this.slices.push({
                    blob: blob,
                    order: i,
                    start: this.start,
                    end: this.end
                });
                this.start = this.end;
            }
            return this.slices;
        }

        /**
         * @description 获取当前文件对象的大小
         * @return {Number}
         * */

    }, {
        key: "getSize",
        value: function getSize() {
            return this.totalSize;
        }

        /**
         * @description 获取当前文件切片块数
         * @return {Number}
         * */

    }, {
        key: "getChunkLength",
        value: function getChunkLength() {
            return this.chunkLength;
        }
    }]);

    return Slice;
}();

exports.default = Slice;

/***/ }),

/***/ "./src/tool.js":
/*!*********************!*\
  !*** ./src/tool.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Tool = function () {
    function Tool() {
        _classCallCheck(this, Tool);
    }

    _createClass(Tool, null, [{
        key: 'makeRandom',

        /**
         * @description 生成随机字符串
         * @return {String}
         * */
        value: function makeRandom() {
            var keys = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            var maxPos = keys.length;
            var str = '';
            for (var i = 0; i < 20; i++) {
                str += keys.charAt(Math.floor(Math.random() * maxPos));
            }
            return str + new Date().getTime();
        }

        /**
         * @description 获取文件名后缀
         * @return {String} 文件名称
         * @return {String}
         * */

    }, {
        key: 'getFileNameSuffix',
        value: function getFileNameSuffix(fileName) {
            return fileName.split('.').pop();
        }
        /**
         * @description 将queryString解析成对象
         * @return {String} queryString
         * @return {Object} 转换之后的对象
         * */

    }, {
        key: 'queryStringToObj',
        value: function queryStringToObj(query) {
            var reg = /([^=&\s]+)[=\s]*([^&\s]*)/g;
            var obj = {};
            while (reg.exec(query)) {
                obj[RegExp.$1] = RegExp.$2;
            }
            return obj;
        }
    }, {
        key: 'deepClone',
        value: function deepClone(origin, target) {
            for (var prop in origin) {
                if (origin.hasOwnProperty(prop)) {
                    //判断是原始值还是引用值 并且不包含null(null其实是原始值，但是typeof返回是'object')
                    if (_typeof(origin[prop]) === 'object' && Object.prototype.toString.call(origin[prop]) !== '[object Null]') {
                        //判断原始值是对象还是数组
                        target[prop] = Object.prototype.toString.call(origin[prop]) === '[object Array]' ? [] : {};
                        Tool.deepClone(origin[prop], target[prop]);
                    } else {
                        //string null undefined number
                        target[prop] = origin[prop];
                    }
                }
            }
            return target;
        }
    }]);

    return Tool;
}();

exports.default = Tool;

/***/ }),

/***/ "./src/upload.js":
/*!***********************!*\
  !*** ./src/upload.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _slice = __webpack_require__(/*! ./slice */ "./src/slice.js");

var _slice2 = _interopRequireDefault(_slice);

var _tool = __webpack_require__(/*! ./tool */ "./src/tool.js");

var _tool2 = _interopRequireDefault(_tool);

var _http = __webpack_require__(/*! ./http */ "./src/http.js");

var _http2 = _interopRequireDefault(_http);

var _getMd = __webpack_require__(/*! ./getMd5 */ "./src/getMd5.js");

var _getMd2 = _interopRequireDefault(_getMd);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var UploadFile = function () {
    function UploadFile(options) {
        _classCallCheck(this, UploadFile);

        // 切片的大小数
        this.chunkSile = options.chunkSile || 10;
        // 请求地址
        this.url = options.url || 'http://127.0.0.1';
        // 请求数据
        this.formData = {};
        // 请求文件
        this.formSleceFile = [];

        // 请求头
        this.headers = {};
        // 回调
        this.callBack = options.callBack || {};
        // 一个切片连续上传几次失败直接断开整个文件上传
        this.sliceTryFreq = options.sliceTryFreq || 10;
        // 是否最后发送MD5值进行校验
        this.isSendCheckMd5 = options.isSendCheckMd5 || false;

        this.delay = options.delay || 0;
    }

    /**
     * @description 追加请求头
     * @param headers {Object} 请求头对象
     * @return {Object} this
     * */


    _createClass(UploadFile, [{
        key: 'appendHeader',
        value: function appendHeader(headers) {
            Object.assign(this.headers, headers);
            return this;
        }

        /**
         * @description 追加请求携带数据
         * @param datas {Object}
         * @return object this
         * */

    }, {
        key: 'appendData',
        value: function appendData(datas) {
            Object.assign(this.formData, datas);
            return this;
        }

        /**
         * @description 追加请求文件数据
         * @param files {Object}
         * @return object this
         * */

    }, {
        key: 'appendFile',
        value: function appendFile(files) {

            // 将文件集合切片放入本对象fromFile
            for (var key in files) {
                var file = null;
                if (!files[key]) {
                    throw new Error('No correct file was selected');
                } else if (files[key].nodeType === 1) {
                    file = files[key]['files'][0];
                } else if (typeof jQuery !== 'undefined' && files[key] instanceof jQuery) {
                    file = files[key][0]['files'][0];
                } else if (files[key] instanceof FileList) {
                    file = files[key][0];
                } else if (files[key] instanceof File) {
                    file = files[key];
                }

                // 实例化切片对象，将文件进行切片、计算等操作
                var slice = new _slice2.default({
                    chunkSile: this.chunkSile,
                    file: file
                });

                // 将文件所有切片存入切片集合
                this.formSleceFile[key] = {
                    totalSize: file.size,
                    fileName: file['name'],
                    // fileKey: Tool.makeRandom() + '.' + Tool.getFileNameSuffix(files[key]['name']),
                    fileKey: _tool2.default.makeRandom(),
                    slices: slice.getSlice(),
                    primordial: file
                };
            }

            return this;
        }
    }, {
        key: 'send',
        value: function send() {
            var _this = this;

            // #a001 上传的所有字段放在数组里面
            var allField = Object.keys(this.formSleceFile);
            // #b001 将进度回调的所有字段名称、回调格式定好
            var progressCallObj = {
                /* fieldName: {
                     totalSize: 0,
                     fileName: '',
                     fileKey: '',
                     chunkLength: 0
                 }
                 */
            };

            // #c001 将获取成功的MD5回到
            var md5CallObj = {};

            // #d001 将每次单文件上传完成的响应存起来
            var allSuccessResult = [];
            // 多文件

            var _loop = function _loop(key) {
                // 单个文件
                var singleFile = _this.formSleceFile[key],

                // 单个文件总共已经上传的字节
                singleLoadedTotal = 0,

                // 临时记录本次与上次的相隔的大小
                s = 0;
                // 进度回调参数
                progressCallObj[key] = {
                    totalSize: singleFile['totalSize'],
                    fileName: singleFile['fileName'],
                    fileKey: singleFile['fileKey'],
                    chunkLength: singleFile['slices'].length,
                    loadedTotalSize: 0
                };
                // 获取文件MD5
                md5CallObj[key] = {
                    field: key,
                    fileKey: singleFile['fileKey'],
                    fileName: singleFile['fileName'],
                    md5: null
                };
                if (_this.isSendCheckMd5) {
                    (0, _getMd2.default)({
                        file: singleFile['primordial'],
                        success: function success(res) {
                            // console.log('md5md5md5md5');
                            md5CallObj[key].md5 = res.md5;
                            // 全部获取成功才进行回调
                            var is = true;
                            for (var _key in md5CallObj) {
                                if (!md5CallObj[_key].md5) {
                                    is = false;
                                }
                            }
                            if (is) {
                                _this.callBack.getFileMd5 && _this.callBack.getFileMd5(md5CallObj);
                                // 发送md5校验

                                var md5Header = [];
                                for (var _key2 in md5CallObj) {
                                    md5Header.push({
                                        'upload-file-id': md5CallObj[_key2]['fileKey'],
                                        md5: md5CallObj[_key2]['md5'],
                                        suffix: _tool2.default.getFileNameSuffix(md5CallObj[_key2]['fileName'])
                                    });
                                }
                                new _http2.default({
                                    callBack: {
                                        checkMd5Result: function checkMd5Result(resp) {
                                            _this.callBack.checkMd5Result && _this.callBack.checkMd5Result(resp);
                                        }
                                    },
                                    sliceTryFreq: _this.sliceTryFreq,
                                    url: _this.url,
                                    isCheckMd5Request: true,
                                    headers: {
                                        'upload-file-md5': JSON.stringify(md5Header)
                                    },
                                    formData: {
                                        'upload-file-md5': JSON.stringify(md5Header)
                                    }

                                }).send();
                            }
                        },
                        progress: function progress(res) {
                            // console.log(res);
                        },
                        complete: function complete(res) {
                            // console.log(res);
                        },

                        error: function error(res) {
                            // console.log(res);
                        }
                    });
                }

                // 多切片,循环将切片加入请求队列
                for (var i = 0; i < singleFile['slices'].length; i++) {
                    // console.log(singleFile['slices'][i]);
                    // 与切片上传所需请求头合并
                    _this.headers = Object.assign(_this.headers, {
                        // 该段起始位置-结束位置
                        'upload-size-range': singleFile['slices'][i].start + '-' + singleFile['slices'][i].end,
                        // 总大小
                        'upload-total-size': singleFile.totalSize,
                        // 总共所需上传次数
                        'upload-total-slice': singleFile['slices'].length,
                        // 当前是第几块
                        'upload-now-order': i + 1,
                        // 当前前端上传key
                        'upload-file-id': singleFile['fileKey']
                    });

                    new _http2.default({
                        callBack: {
                            // 每个切片实时上传回调
                            progress: function progress(_progress) {
                                if (singleLoadedTotal === 0) {
                                    // 如果第一次为0，直接等于
                                    singleLoadedTotal = _progress[key];
                                } else {
                                    // e加等于本次实时减去上一次结束的
                                    singleLoadedTotal += _progress[key] - s;
                                }

                                // #b002 将文件实时上传情况回调
                                progressCallObj[key].loadedTotalSize = singleLoadedTotal;

                                _this.callBack.progress &&
                                /*浏览器打印对象时如果对象未展开，由于对象引用问题，
                                最后展开会导致显示不准确，所以采用深拷贝解决，更利于调试*/
                                _this.callBack.progress(_tool2.default.deepClone(progressCallObj, {}));

                                // 记录上一次结束的
                                s = _progress[key];
                            },
                            // 一个文件(全部切片)上传成功回调
                            singleSuccess: function singleSuccess(resp) {
                                try {
                                    _this.callBack.singleSuccess && _this.callBack.singleSuccess({
                                        field: resp.field,
                                        response: typeof resp.response === 'string' ? JSON.parse(resp.response) : resp.response
                                    });

                                    // #d002
                                    allSuccessResult.push({
                                        field: resp.field,
                                        response: typeof resp.response === 'string' ? JSON.parse(resp.response) : resp.response
                                    });

                                    // #a002 判断是否全部上传完成
                                    for (var k = 0; k < allField.length; k++) {
                                        if (key === allField[k]) {
                                            // 上传一个移除
                                            allField.splice(k, 1);
                                            break;
                                        }
                                    }
                                    if (allField.length === 0) {
                                        // #a003
                                        _this.callBack.allSuccess && _this.callBack.allSuccess(allSuccessResult);
                                    }
                                } catch (e) {
                                    throw new Error(e.toString());
                                }
                            },
                            // 一块切片上传成功回调
                            sliceSuccess: function sliceSuccess() {
                                // 一块上传完成重置临时记录的大小
                                s = 0;
                            },
                            error: function error(resp) {
                                console.log(resp);
                            },

                            // 某个文件由于某个切片上传连续失败回调
                            tryFreqError: function tryFreqError(errorMsg) {

                                _this.callBack.tryFreqError && _this.callBack.tryFreqError(errorMsg);
                            }
                        },
                        url: _this.url,
                        sliceTryFreq: _this.sliceTryFreq,
                        headers: _this.headers,
                        formData: _this.formData,
                        fileData: {
                            fieldName: key,
                            fileName: singleFile['fileName'],
                            fileKey: singleFile['fileKey'],
                            file: singleFile['slices'][i],
                            order: i
                            //
                            // [key]: {
                            //     fileName: singleFile['fileName'],
                            //     fileKey: singleFile['fileKey'],
                            //     file: singleFile['slices'][i]
                            // }
                        },
                        delay: _this.delay
                    }).send();
                }
            };

            for (var key in this.formSleceFile) {
                _loop(key);
            }
        }
    }]);

    return UploadFile;
}();

exports.default = UploadFile;

/***/ })

/******/ });
});
//# sourceMappingURL=simple-upload-slice-file.min.js.map